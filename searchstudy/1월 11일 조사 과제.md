# Hikari 라이브러리
> 서버가 DB에 연결하기 위한 연결 비용이 가장 많이 들어가는데 이를 보완하기위해 사용하는 것
* `Connection pool` : 데이터베이스와 연결된 커넥션을 미리 만들어 놓고 이를 pool에서 관리하는 것
* 스레드풀과 비슷한 개념이다

### HikariCP
> 가벼운 용량과 속도를 가지는 JDBC의 커넥션 풀 프레임워크
* springboot는 커넥션을 관리하기 위해서 이것을 사용한다
* Thread가 커넥션을 요청했을 때 존재하는 커넥션이 있다면 그 커넥션을 반환한다
* 만약 존재하지 않는다면 다른 Thread가 커넥션을 반납하기를 기다린다

# Open-in-View
> true와 false값을 가지는 속성
* `true` : 영속성 컨텍스트가 트랜잭션 범위를 넘어서까지 살아있다
  * API라면 클라이언트에게 응답될 때까지,  View라면 View가 렌더링 될 때까지 살아있다
* `false` : 트랜잭션을 종료할 때 영속성 컨텍스트도 닫힌다

# create-drop
> Spring에서 JPA/Hibernate 초기화전략

### DDL Generation
> Spring은 EntityScan을 통해 @Entity 어노테이션이 명시한 클래스는 찾는다

이때 spring.jpa.generat-ddl=true를 근거로 서버 시작 시점에 DDL 문을 생성하여 DB에 적용한다
#### 옵션값
* `none` : 아무것도 실행하지 않는다
* `create-drop` : SessionFactory가 시작될 때 drop 및 생성을 실행하고 SessionFactory가 종료될 때 drop을 실행한다
* `create` : SessionFactory가 시작될 때 베이스 drop을 실행하고 생성된 DDL을 실행한다
* `update` : 변경된 스키마를 적용한다
* `validate` : 변경된 스키마가 있다면 변경점을 출력하고 애플리케이션을 종료한다

# readOnly
## Tanstaction
> 데이터베이스의 상태를 변경하고자 할 때, 원자성을 지켜서 수행되어야 하는 연산들


    @Transcational(readOnly=true)
* 읽기 전용으로 만들면 영속성 컨텍스트는 변경 감지를 위한 스냅샷을 보관하지 않으므로 성능이 향상된다
* 엔티티의 등록, 수정, 삭제가 동작하지 않는다
## 사용했을 때의 이점
* 조회한 데이터를 의도치 않게 변경하게 되는 경우를 막는다
* CRUD 중 CUD가 동작되지 않며, 스냅샷 저장, 변경 감지 작업을 수행하지 않아 성능이 향상된다
* DB 서버의 부하를 줄이고 약간의 최적화가 가능하다
* 어노테이션을 붙여줌으로써 그 메소드를 본 사람이 이 메소드가 하는 일을 알 수 있게 한다

# @PathVariable
> REST API에서 URI에 변수가 들어가는 경우를 처리해준다

    @RestController
    public class Controller {
        
        @GetMapping("/member/{name}")
        public String findById(@PathVariable("name") String name) {
            return "Name: " + name;
        }
    }
# @RequestBody
> HTTP 요청의 본문이 그대로 전달된다
* 일반적인 GET|POST 보다 XML이나 JSON 기반 통신에서 더 유리하다


    @RequestMapping("/test/request")
    public String test(@RequestBody Entity entity) {
        System.out.println(entity.getName());

        return "test/login-page";
    }
# @ResponseBody
> 자바 객체를 HTTP 요청의 바디 내용으로 매핑하여 클라이언트로 전송한다
* 이 어노테이션이 붙은 파라미터가 있으면 HTTP 요청의 미디어 타입과 파라미터 타입을 먼저 확인한다


    @ResponseBody
    @RequestMapping("/test/response")
    public Entity sampleCode() {
        Entity entity = new Entity();
        entity.setName("김기현");
        return entity;
    }

# Transactional
> 스프링은 @Transactional 어노테이션을 이용한 선언적 트랜잭션 처리를 지원한다

## Transaction이란?
> CRUD 작업 중 오류가 발생했을 때 모든 작업을 원 상태로 되돌릴 수 있게 해주는 것

## @Transactional
> DB와 관련된 혹은 트랜잭션이 필요한 서비스 클래스 또는 메소드에 어노테이션을 달아주면 된다

이 어노테이션이 붙은 메소드는 메소드가 포함하고 있는 작업 중 하나라도 실패할 경우 전체 작업을 취소한다
### 옵션
* `isolation` : 트랜잭션 고립 수준을 설정한다
* `propagation` : 동작 도중 자른 트랜잭션을 호출할 때 어떻게 할 것인지 지정
* `noRollBackFor` : 특정 예외 발생시 rollback이 동작하지 않도록 한다
* `rollBackFor` : 특정 예외 발생시 롤백이 동작하도록 한다
* `timeout` : 지정한 시간 내에 메소드 수행이 완료되지 않으면 rollback이 동작하도록 한다
* `readOnly` : 트랜잭션을 읽기 전용으로 설정한다

# Produces / Consumes
* @Consumes : 수신하고자 하는 데이터 포켓을 정의한다
* @Produces : 출력하고자 하는 데이터 포멧을 정의한다

> 요청 타입 제한하기

    @Controller
    public class TestController {
        
        @GetMapping(values = "/test", consumes = MediaType.APPLICATION_JSON_UTF8_VALUE)
        public String hello(){
            return "hello";
        }
* 이는 ResponseBody에 담는 타입을 제한할 수 있다
* JSON 데이터 요청만 처리하겠다는 의미이다

>응답 타입 제한하기

    @PostMapping(value ="/hello", produces = MediaType.TEXT_PLAIN_VALUE)
    @ResponseBody
    public String hello(){
        return "hello";
    }
* TEST 값만 응답하겠다는 말이다
* 다른 값으로는 응답하지 않는다

# 코딩 과제
다른 레포에 똑같이 만들어둔 것이 있어서 이번에는 그쪽 링크를 올립니다
[Code](https://github.com/KimKiHyun0206/se-todo-study-kihyun/tree/23.1.11-study)